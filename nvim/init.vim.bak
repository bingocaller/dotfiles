set runtimepath+=~/.vim,~/.vim/after
set packpath+=~/.vim
source ~/.vimrc

"  Make search/replace interactive without the split pane
set inccommand=nosplit

" Don't load Python2 provider
let g:loaded_python_provider = 0

let g:markdown_fenced_languages = [ 'html', 'javascript', 'typescript', 'css', 'scss', 'lua', 'vim' ]

" ----------------
" Window switching
" ----------------

" Alt + hjkl: jump between windows
" Alt + HJKL: move windows around
tnoremap <a-h> <c-\><c-n><c-w>h
tnoremap <a-j> <c-\><c-n><c-w>j
tnoremap <a-k> <c-\><c-n><c-w>k
tnoremap <a-l> <c-\><c-n><c-w>l
tnoremap <a-H> <c-\><c-n><c-w>H
tnoremap <a-J> <c-\><c-n><c-w>J
tnoremap <a-K> <c-\><c-n><c-w>K
tnoremap <a-L> <c-\><c-n><c-w>L
nnoremap <a-h> <c-w>h
nnoremap <a-j> <c-w>j
nnoremap <a-k> <c-w>k
nnoremap <a-l> <c-w>l
nnoremap <a-H> <c-w>H
nnoremap <a-J> <c-w>J
nnoremap <a-K> <c-w>K
nnoremap <a-L> <c-w>L

" Tab switching
tnoremap <a-]> <c-\><c-n>gt
nnoremap <a-]> gt
tnoremap <a-[> <c-\><c-n>gT
nnoremap <a-[> gT

tnoremap <a-1> <c-\><c-n>1gt
tnoremap <a-2> <c-\><c-n>2gt
tnoremap <a-3> <c-\><c-n>3gt
tnoremap <a-4> <c-\><c-n>4gt
tnoremap <a-5> <c-\><c-n>5gt
tnoremap <a-6> <c-\><c-n>6gt
tnoremap <a-7> <c-\><c-n>7gt
tnoremap <a-8> <c-\><c-n>8gt
tnoremap <a-9> <c-\><c-n>9gt
nnoremap <a-1> 1gt
nnoremap <a-2> 2gt
nnoremap <a-3> 3gt
nnoremap <a-4> 4gt
nnoremap <a-5> 5gt
nnoremap <a-6> 6gt
nnoremap <a-7> 7gt
nnoremap <a-8> 8gt
nnoremap <a-9> 9gt

" --------------
" Terminal stuff
" --------------

" Open terminal
nnoremap <leader>t :terminal<cr>
" Helpful terminal mode shortcuts
" Switch to normal mode with <Esc>
" tnoremap <Esc> <C-\><C-n>
" Backup Esc event
" tnoremap <A-[> <Esc>
tnoremap <A-[> <C-\><C-n>
" Paste into terminal from register
tnoremap <expr> <A-r> '<C-\><C-n>"'.nr2char(getchar()).'pi'

" Specify Node path for neovim via Volta
" https://github.com/volta-cli/volta/issues/866#issuecomment-730476125
if executable('volta')
  let g:node_host_prog = trim(system("volta which neovim-node-host"))
endif

" ---------------
" Code completion
" ---------------

" Give more space for displaying messages.
set cmdheight=2

" Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
" delays and poor user experience.
set updatetime=300

" Don't pass messages to |ins-completion-menu|.
set shortmess+=c

" Completion menu tweaks: show menu, show even if only one option is
" available, don't select anything automatically.
" Default value: menu,preview
set completeopt=menu,menuone,noselect

" Always show the signcolumn, otherwise it would shift the text each time
" diagnostics appear/become resolved.
if has("patch-8.1.1564")
    " Recently vim can merge signcolumn and number column into one
    set signcolumn=number
else
    set signcolumn=yes
endif

" " Highlight the symbol and its references when holding the cursor.
" autocmd CursorHold * silent call CocActionAsync('highlight')

" -------
" Plugins
" -------

if empty(glob('~/.vim/autoload/plug.vim'))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

call plug#begin('~/.vim/plugged')
" Utilities & niceness
Plug 'airblade/vim-gitgutter'
Plug 'christoomey/vim-sort-motion'
Plug 'inkarkat/vim-ReplaceWithRegister'
Plug 'machakann/vim-highlightedyank'
Plug 'tommcdo/vim-exchange'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-sleuth'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
" Custom text objects
Plug 'kana/vim-textobj-user'
Plug 'jasonlong/vim-textobj-css'
" Completions
Plug 'mattn/emmet-vim'
" FZF
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
" Focus mode
Plug 'junegunn/goyo.vim'
" Flow
" Plug 'flowtype/vim-flow'
" styled-components
" Plug 'styled-components/vim-styled-components', { 'branch': 'main' }
" Jinja / Nunjucks
" Plug 'Glench/Vim-Jinja2-Syntax'
" Plug 'lepture/vim-jinja'
" Fish
Plug 'dag/vim-fish'
" Color scheme
Plug 'haishanh/night-owl.vim'

" nvim-tree (file explorer)
Plug 'kyazdani42/nvim-web-devicons'
Plug 'kyazdani42/nvim-tree.lua'
" Lualine
Plug 'hoob3rt/lualine.nvim'
" Indent blank lines
Plug 'lukas-reineke/indent-blankline.nvim'
" Conquer of Completion
" Plug 'neoclide/coc.nvim', {'branch': 'release'}
" LSP Config
Plug 'neovim/nvim-lspconfig'
" Autocomplete
Plug 'hrsh7th/cmp-nvim-lsp'
Plug 'hrsh7th/cmp-buffer'
Plug 'hrsh7th/nvim-cmp'

Plug 'mhartington/formatter.nvim'

" Markdown preview.
" This install method only works if nodejs and yarn are available
Plug 'iamcco/markdown-preview.nvim', { 'do': 'cd app && yarn install'  }
" Treesitter
Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}  " We recommend updating the parsers on update
" Update commenstring dynamically, even in complex file types
Plug 'JoosepAlviste/nvim-ts-context-commentstring'

call plug#end()

" ---------------
" Plugin settings
" ---------------

" haishanh/night-owl.vim
if (has("termguicolors"))
    set termguicolors
endif
" set Vim-specific sequences for RGB colors
let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
colorscheme night-owl

" Add better Tabline colours
hi TabLineFill guifg=#02233e guibg=fg
hi TabLine guibg=#023055 guifg=#4e6e88
hi TabLineSel guibg=bg guifg=fg

" machakann/vim-highlightedyank
if !exists('##TextYankPost')
    map y <Plug>(highlightedyank)
endif

" ---
" FZF
" ---

map <C-p> :Files<cr>
map <C-b> :Buffers<cr>
map <C-h> :History<cr>
map <a-p> :Commands<cr>
map <a-w> :Windows<cr>

" Don't use window layout
let g:fzf_layout = { 'down': '40%' }

" [Buffers] Jump to the existing window if possible
let g:fzf_buffers_jump = 1

" ---
" Coc
" ---

" " Help coc-css with @s in SCSS files
" autocmd FileType scss setl iskeyword+=@-@

" " From Coc example configuration
" " https://github.com/neoclide/coc.nvim#example-vim-configuration

" " Use tab for trigger completion with characters ahead and navigate.
" " NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
" " other plugin before putting this into your config.
" inoremap <silent><expr> <TAB>
"             \ pumvisible() ? "\<C-n>" :
"             \ <SID>check_back_space() ? "\<TAB>" :
"             \ coc#refresh()
" inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

" function! s:check_back_space() abort
"     let col = col('.') - 1
"     return !col || getline('.')[col - 1]  =~# '\s'
" endfunction

" " Use <C-Space> to trigger completion.
" inoremap <silent><expr> <c-space> coc#refresh()

" " Use <cr> to confirm completion, `<C-g>u` means break undo chain at current
" " position. Coc only does snippet and additional edit on confirm.
" " <cr> could be remapped by other vim plugin, try `:verbose imap <CR>`.
" if exists('*complete_info')
"     inoremap <expr> <cr> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<CR>"
" else
"     inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
" endif

" " GoTo code navigation.
" nmap <silent> gd <Plug>(coc-definition)
" nmap <silent> gy <Plug>(coc-type-definition)
" nmap <silent> gi <Plug>(coc-implementation)
" nmap <silent> gr <Plug>(coc-references)

" " Use K to show documentation in preview window, fallback to :help.
" nnoremap <silent> K :call <SID>show_documentation()<CR>

" function! s:show_documentation()
"     if (index(['vim','help'], &filetype) >= 0)
"         execute 'h '.expand('<cword>')
"     else
"         call CocAction('doHover')
"     endif
" endfunction

" " Highlight the symbol and its references when holding the cursor.
" autocmd CursorHold * silent call CocActionAsync('highlight')

" " Symbol renaming.
" nmap <leader>rn <Plug>(coc-rename)

" " Formatting selected code. Works as a motion and with visual mode.
" xmap <leader>f <Plug>(coc-format-selected)
" nmap <leader>f <Plug>(coc-format-selected)

" augroup cocautocmdgroup
"     autocmd!
"     " Setup formatexpr specified filetype(s).
"     autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
"     " Update signature help on jump placeholder.
"     autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
" augroup end

" " Applying codeAction to the selected region.
" " Example: `<leader>aap` for current paragraph
" xmap <leader>a <Plug>(coc-codeaction-selected)
" nmap <leader>a <Plug>(coc-codeaction-selected)

" " Remap keys for applying codeAction to the current buffer.
" nmap <leader>ac <Plug>(coc-codeaction)
" " Apply AutoFix to problem on the current line.
" nmap <leader>qf <Plug>(coc-fix-current)

" " Map function and class text objects
" " NOTE: Requires 'textDocument.documentSymbol' support from the language server.
" xmap if <Plug>(coc-funcobj-i)
" omap if <Plug>(coc-funcobj-i)
" xmap af <Plug>(coc-funcobj-a)
" omap af <Plug>(coc-funcobj-a)
" xmap ic <Plug>(coc-classobj-i)
" omap ic <Plug>(coc-classobj-i)
" xmap ac <Plug>(coc-classobj-a)
" omap ac <Plug>(coc-classobj-a)

" " Use CTRL-S for selections ranges.
" " Requires 'textDocument/selectionRange' support of LS, ex: coc-tsserver
" nmap <silent> <C-s> <Plug>(coc-range-select)
" xmap <silent> <C-s> <Plug>(coc-range-select)

" " Add `:Format` command to format current buffer.
" command! -nargs=0 Format :call CocAction('format')

" " Add `:Fold` command to fold current buffer.
" command! -nargs=? Fold :call CocAction('fold', <f-args>)

" " Add `:OR` command for organize imports of the current buffer.
" command! -nargs=0 OR :call CocAction('runCommand', 'editor.action.organizeImport')

" " Mappings for CoCList
" " Show all diagnostics.
" nnoremap <silent> <leader>di :<C-u>CocList diagnostics<cr>
" " Manage extensions.
" nnoremap <silent><nowait> <leader>ex :<C-u>CocList extensions<cr>
" " Show commands.
" nnoremap <silent><nowait> <leader>c :<C-u>CocList commands<cr>
" " Find symbol of current document.
" nnoremap <silent><nowait> <leader>o :<C-u>CocList outline<cr>
" " Search workspace symbols.
" nnoremap <silent><nowait> <leader>sy :<C-u>CocList -I symbols<cr>
" " Do default action for next item.
" " nnoremap <silent><nowait> <space>j  :<C-u>CocNext<CR>
" " Do default action for previous item.
" " nnoremap <silent><nowait> <space>k  :<C-u>CocPrev<CR>
" " Resume latest coc list.
" " nnoremap <silent><nowait> <space>p  :<C-u>CocListResume<CR>

" " " Scroll inside pop-up/floating windows using keyboard
" " nnoremap <nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
" " nnoremap <nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
" " noremap <nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
" " noremap <nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"

" nvim-tree
lua <<EOF
-- Necessary to initialise nvim-tree
-- following options are the default
require'nvim-tree'.setup {
  -- open the tree when running this setup function
  open_on_setup       = true,
  -- show lsp diagnostics in the signcolumn
  lsp_diagnostics     = true,
  -- update the focused file on `BufEnter`, un-collapses the folders recursively until it finds the file
  view = {
    -- width of the window, can be either a number (columns) or a string in `%`
    width = 40,
    -- side of the tree, can be one of 'left' | 'right' | 'top' | 'bottom'
    side = 'right',
    -- if true the tree will resize itself after opening a file
    auto_resize = false,
  }
}
EOF

let g:nvim_tree_gitignore = 1 "0 by default
let g:nvim_tree_quit_on_open = 1 "0 by default, closes the tree when you open a file
let g:nvim_tree_highlight_opened_files = 1 "0 by default, will enable folder and file icon highlight for opened files/directories.

nnoremap <C-n> :NvimTreeToggle<CR>
nnoremap <leader>r :NvimTreeRefresh<CR>
nnoremap <leader>n :NvimTreeFindFile<CR>

" Lualine
lua <<EOF
require'lualine'.setup {
  options = {
    theme = 'nightfly',
    component_separators = {'|', '|'},
    section_separators = {'', ''},
    disabled_filetypes = {}
  },
  extensions = {'nvim-tree'}
}
EOF

" ----------------
" Language servers
" ----------------
"

lua <<EOF
local nvim_lsp = require('lspconfig')

--Enable (broadcasting) snippet capability for completion. Used by several LSs.
local capabilities = vim.lsp.protocol.make_client_capabilities()
capabilities.textDocument.completion.completionItem.snippetSupport = true

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
local on_attach = function(client, bufnr)
  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

  -- Enable completion triggered by <c-x><c-o>
  buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- Mappings.
  local opts = { noremap=true, silent=true }

  -- See `:help vim.lsp.*` for documentation on any of the below functions
  buf_set_keymap('n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)
  buf_set_keymap('n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)
  buf_set_keymap('n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
  buf_set_keymap('n', 'K', '<cmd>lua vim.lsp.buf.hover()<CR>', opts)
  buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
  buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
  buf_set_keymap('n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
  -- buf_set_keymap('n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
  -- buf_set_keymap('n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
  -- buf_set_keymap('n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
  buf_set_keymap('n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
  buf_set_keymap('n', '<space>ca', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)
  buf_set_keymap('n', '<space>e', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
  buf_set_keymap('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
  buf_set_keymap('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
  -- buf_set_keymap('n', '<space>q', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)
  buf_set_keymap('n', '<space>f', '<cmd>lua vim.lsp.buf.formatting()<CR>', opts)

end

-- Use a loop to conveniently call 'setup' on multiple servers and
-- map buffer local keybindings when the language server attaches
local servers = {
    'bashls',
    'cmake',
    -- Deno needs a bit more setup in order to coexist with tsserver
    -- See https://github.com/neovim/nvim-lspconfig/issues/927
    -- 'denols', 
    'dockerls',
    'pyright',
    'rust_analyzer',
    'sqlls',
    'stylelint_lsp',
    'svelte',
    'tsserver',
    'vimls',
    'yamlls',
    'zk'
}
for _, lsp in ipairs(servers) do
  nvim_lsp[lsp].setup {
    on_attach = on_attach,
    flags = {
      debounce_text_changes = 150,
    }
  }
end

----------------------------------------------------------
-- Language servers that require more custom configuration
----------------------------------------------------------

-- Emmet (https://github.com/aca/emmet-ls)

if not nvim_lsp.emmet_ls then    
  require'lspconfig/configs'.emmet_ls = {    
    default_config = {    
      cmd = {'emmet-ls', '--stdio'};
      filetypes = {'html', 'css', 'scss', 'jsx', 'tsx'};
      root_dir = function(fname)    
        return vim.loop.cwd()
      end;    
      settings = {};
    };    
  }    
end    

-- CSS, HTML, JSON
-- Provided by https://github.com/hrsh7th/vscode-langservers-extracted

local capabilities_servers = { 'cssls', 'emmet_ls', 'html', 'jsonls' }

for _, server in ipairs(servers) do
    nvim_lsp[server].setup {
        capabilities = capabilities,
        commands = {
            Format = {
                function()
                    vim.lsp.buf.range_formatting({},{0,0},{vim.fn.line("$"),0})
                end
            }
        },
        on_attach = on_attach,
        flags = {
            debounce_text_changes = 150,
        }
    }
end

-- Lua

-- Set Lua LSP `cmd`
local system_name
if vim.fn.has("mac") == 1 then
    system_name = "macOS"
elseif vim.fn.has("unix") == 1 then
    system_name = "Linux"
elseif vim.fn.has('win32') == 1 then
    system_name = "Windows"
else
    print("Unsupported system for sumneko")
end

-- set the path to the sumneko installation; if you previously installed via the now deprecated :LspInstall, use
local sumneko_root_path = '/Users/bingocaller/dev/lua-language-server'
local sumneko_binary = sumneko_root_path.."/bin/"..system_name.."/lua-language-server"

local runtime_path = vim.split(package.path, ';')
table.insert(runtime_path, "lua/?.lua")
table.insert(runtime_path, "lua/?/init.lua")

nvim_lsp.sumneko_lua.setup {
  cmd = {sumneko_binary, "-E", sumneko_root_path .. "/main.lua"};
  on_attach = on_attach,
  flags = {
      debounce_text_changes = 150,
  },
  settings = {
    Lua = {
      runtime = {
        -- Tell the language server which version of Lua you're using (most likely LuaJIT in the case of Neovim)
        version = 'LuaJIT',
        -- Setup your lua path
        path = runtime_path,
      },
      diagnostics = {
        -- Get the language server to recognize the `vim` global
        globals = {'vim'},
      },
      workspace = {
        -- Make the server aware of Neovim runtime files
        library = vim.api.nvim_get_runtime_file("", true),
      },
      -- Do not send telemetry data containing a randomized but unique identifier
      telemetry = {
        enable = false,
      },
    },
  },
}
EOF

lua <<EOF
------------
-- Formatter
------------

-- Prettier function for formatter
local prettier = function()
  return {
    exe = "prettier",
    args = { "--stdin-filepath", vim.api.nvim_buf_get_name(0) },
    stdin = true,
  }
end

local stylelint = function()
  return {
    exe = "stylelint",
    args = {  "--fix", "--stdin-filename", vim.api.nvim_buf_get_name(0) },
    stdin = true,
  }
end

require("formatter").setup({
  logging = false,
  filetype = {
    javascript = { prettier },
    javascriptreact = { prettier },
    typescript = { prettier },
    typescriptreact = { prettier },
    css = { stylelint },
    scss = { stylelint },
    lua = {
      -- Stylua
      function()
        return {
          exe = "stylua",
          args = { "--indent-width", 2, "--indent-type", "Spaces" },
          stdin = false,
        }
      end,
    },
  },
})

-- Runs Formatter on save
vim.api.nvim_exec(
  [[
augroup FormatAutogroup
  autocmd!
  autocmd BufWritePost *.js,*.jsx,*.ts,*.tsx,*.css,*.scss,*.lua : FormatWrite
augroup END
]],
  true
)
EOF

" Autocomplete
" Using nvim-cmp: https://github.com/hrsh7th/nvim-cmp/
" and this config: https://github.com/neovim/nvim-lspconfig/wiki/Autocompletion
lua <<EOF
  -- Setup nvim-cmp.
  local cmp = require'cmp'

  local check_back_space = function()
    local col = vim.fn.col '.' - 1
    return col == 0 or vim.fn.getline('.'):sub(col, col):match '%s' ~= nil
  end

  cmp.setup {
    -- snippet = {
    --   expand = function(args)
    --     require('luasnip').lsp_expand(args.body)
    --   end,
    -- },
    mapping = {
      ['<C-p>'] = cmp.mapping.select_prev_item(),
      ['<C-n>'] = cmp.mapping.select_next_item(),
      ['<C-d>'] = cmp.mapping.scroll_docs(-4),
      ['<C-f>'] = cmp.mapping.scroll_docs(4),
      ['<C-Space>'] = cmp.mapping.complete(),
      ['<C-e>'] = cmp.mapping.close(),
      ['<CR>'] = cmp.mapping.confirm {
        behavior = cmp.ConfirmBehavior.Replace,
        select = true,
      },
      ['<Tab>'] = function(core, fallback)
        if vim.fn.pumvisible() == 1 then
          vim.fn.feedkeys(vim.api.nvim_replace_termcodes('<C-n>', true, true, true), 'n')
        -- elseif luasnip.expand_or_jumpable() then
        --   vim.fn.feedkeys(vim.api.nvim_replace_termcodes('<Plug>luasnip-expand-or-jump', true, true, true), '')
        elseif not check_back_space() then
          cmp.mapping.complete()(core, fallback)
        else
          vim.cmd(':>')
        end
      end,
      ['<S-Tab>'] = function(fallback)
        if vim.fn.pumvisible() == 1 then
          vim.fn.feedkeys(vim.api.nvim_replace_termcodes('<C-p>', true, true, true), 'n')
        -- elseif luasnip.jumpable(-1) then
        --   vim.fn.feedkeys(vim.api.nvim_replace_termcodes('<Plug>luasnip-jump-prev', true, true, true), '')
        else
          vim.cmd(':<')
        end
      end,
    },
    sources = {
      { name = 'nvim_lsp' },
      -- { name = 'luasnip' },
    },
  }
EOF

"-------------------
" Treesitter modules
" From: https://github.com/nvim-treesitter/nvim-treesitter#available-modules

lua <<EOF
require'nvim-treesitter.configs'.setup {
    ensure_installed = "maintained", -- one of "all", "maintained" (parsers with maintainers), or a list of languages
        
    -- List of parsers to ignore installing
    ignore_install = {
        "beancount",
        "bibtex",
        "cuda",
        "devicetree",
        "dot",
        "fennel",
        "gdresource",
        "gdscript",
        "gomod",
        "hcl",
        "heex",
        "ledger",
        "pioasm",
        "ql",
        "sparql",
        "supercollider",
        "surface",
        "teal",
        "tlaplus",
        "turtle",
        "verilog",
        "yang"
    },

    -- https://github.com/JoosepAlviste/nvim-ts-context-commentstring
    context_commentstring = {
        enable = true
    },

    -- Core module
    highlight = {
        enable = true,              -- false will disable the whole extension

        -- custom_captures = {
        --     -- Highlight the @foo.bar capture group with the "Identifier" highlight group.
        --     ["foo.bar"] = "Identifier",
        -- },

        -- disable = { "c", "rust" },  -- list of language that will be disabled

        -- Setting this to true will run `:h syntax` and tree-sitter at the same time.
        -- Set this to `true` if you depend on 'syntax' being enabled (like for indentation).
        -- Using this option may slow down your editor, and you may see some duplicate highlights.
        -- Instead of true it can also be a list of languages
        additional_vim_regex_highlighting = false,
    },

    -- Core module
    incremental_selection = {
        enable = true,
        keymaps = {
            init_selection = "gnn",
            node_incremental = "grn",
            scope_incremental = "grc",
            node_decremental = "grm",
        },
    },

    -- Core module
    indent = {
        enable = true
    }
}
EOF

